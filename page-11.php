<?php get_header(); ?>
<!-- main and sidebar -->
<?php get_sidebar(); ?>
    <main class="col-md-10 bg-content">


      <?php while ( have_posts() ) : the_post(); ?>
        <article <?php post_class('post'); ?> id="post-<?php the_ID(); ?>">
          <header>
            <h2><a href="<?php the_permalink(); ?>" rel="bookmark"><?php  the_title(); ?></a></h2>
          </header>

          <p>Свойства объекта - это обычная переменная
          <p>Поведение описывается методами - это обычная функция
          <br>
          <p>Нейм это локальная переменная функции
          <p>Есть ключевое слово this 
          <p>Обращению из методов к свойствам только через this
          <p>this->name;
          <p>это ссылка на тот объект который его вызвал
          <p>Обращение метода к другому методу через this
            <br>
          <p>Наименование начинается с больших букв



          <h3>Лабараторка</h3>

          <?php
            class User {
              public $name;
              public $login;
              public $password;
              public function showInfo(){
                echo "<p>Name:".$this->name;
                echo "<br>Login:".$this->login;
                echo "<br>Password:".$this->password;
              }
            }
            $user1 = new User;
            $user1->name = 'John Smith';
            $user1->login = 'john';
            $user1->password = '12345';
            $user1->showInfo();

            $user2 = new User;
            $user2->name = 'Mike Dow';
            $user2->login = 'mike';
            $user2->password = '0000';
            $user2->showInfo();

            $user3 = new User;
            $user3->name = 'Ivan Petrov';
            $user3->login = 'ivan';
            $user3->password = '1111';
            $user3->showInfo();
          ?>
          <br>
          <p>Паблик означает доступна в глобальной видимости
          <br>
          
          <br>
          <h2>Псевдоконстанты</h2> 
          <p>Псевдоконстанта класса, вернет имя класса.
          <p>Псевдоконстанта метода вернет - имя класса двойное двоеточие имя метода, не только имя метода но и к какому классу он пренадлежит
          <p>Псевдоконстанта фанкшен вернет только имя метода
          <p>
          <?php
            class MyClass {
              public function MyMethod(){
                echo "<p>вызов метода ". __METHOD__;

              }
              public function GetClassName(){
                echo "<p>имя класса ". __CLASS__;

              }
            }
            $obj = new MyClass();
            echo $obj->MyMethod();
            // MyClass::MyMethod
            echo $obj->GetClassName();
            // MyClass
          ?>
          <p>
          <h2>Конструктор</h2>
          <p>Часто бывает нужно сделать одно и тоже действие при создании объекта. Допустим подключиться к базе данных.
          <p>Это метод который автоматически вызывается при создании объекта
          <p>
          <?php
            class MyClass2 {
              function __construct(){
                echo "<p>* объект создан ";
              }
            }
            $obj = new MyClass2(); 
          ?>
          <p>Два подчеркивания - это так называемые магические функции
          <p>Так как конструктор это функция то в нее можно что-то передать.
          <p>
          <?php
            class MyClass3 {
              function __construct($num){
                echo "<p>* объект создан $num";
              }
            }
            $obj = new MyClass3(3); 
          ?>
          <p>
          <h2>Деструктор</h2>
          <p>
          <p>Унасть есть сделать что-то когда объект создается, а есть необходимость что-то сделать когда объект удаляется(код закончился, или ансетом удалили)
          <p>Вызывается автоматом при удалении
          <p>служебное имя destruct
          <p>
         <?php
            class MyClass4 {
              function __construct($num){
                echo "<p>* объект создан $num";
              }
              function __destruct(){
                echo "<p>* объект удален";
              }
            }
            $obj = new MyClass4(4); 
          ?>
          <p>1) Не смотря что у него есть круглые скобки, но в них не чего неьлзя передать
          <p>2) Очередность удаления неопределена. Не кто не знает в какой последовательности объекты удаляются.
          <p>Правило: из деструктора не обращаться к другим объектом. На момент вызова деструктора того объекта может уже не быть.
          <p>
          <h3>Лабараторка 1.2</h3>
          <p>
          <p>Так принято, что конструктор и деструктор описываются в начале
          <?php
            class User2 {
              function __construct($name, $login, $pass){
                $this->name = $name;
                $this->login = $login;
                $this->password = $pass;
              }
              function __destruct(){
                echo "<br>Пользователь ".$this->name.' удален';
              } 
              public function showInfo(){
                echo "<p>Name:".$this->name;
                echo "<br>Login:".$this->login;
                echo "<br>Password:".$this->password;
              }
            }
            $user1 = new User2('John Smith','john','12345');
            $user1->showInfo();

            $user2 = new User2('Mike Dow','mike','0000');
            $user2->showInfo();

            $user3 = new User2('Ivan Petrov','ivan','1111');
            $user3->showInfo();
          ?>
          <p>
          <p>Можно ли конструктор вызвать как обычный метод? - можно. Но сложно представить за чем это нужно.
          <p>В других языках имя метода конструктора должно имеет имя класса, без использования слова __construct. 
          <p>в пхп это сделано для понятности. В ПХП4 был как и у других языках. 
          <p>В ПХП5 он ищит __констракт, если он его не найдет он продалжает искать одноименный метод(как в других языках).
          <p>
           <?php
              class MyClass5 {
                function __construct($num){
                  echo "<p>* объект создан $num";
                }
                function __destruct(){
                  echo "<p>* объект удален ".__CLASS__;
                }
                function __clone(){
                  echo "<p>** объект ".__CLASS__." клонирован ";
                }
              }
            ?>
          <p>
          <?php
            $a = $b; // копируем значение из б в а
            $a = &$b; // а является ссылкой на б
            // в четвертом пхп это работало для всех типов
            // в пятом это работает для всех кроме объектов
            $a = $b; // в пятом, а это ссылка на объект б

            $obj = new MyClass(); // в четвортом это конструкция довала нам два объекта. Один в виртуалке другой в переменной
            $obj =& new MyClass(); // добавляли &, за чем мне два объекта один я не использую
            $obj = new MyClass5(5); // в пятом он создался, а переменная $obj это ссылка на него
            // когда удаляется объект? - тогда когда на него не ведет не одна ссылка
            // как же нам копировать объект, если а=б это просто ссылка? - с помощью ключевого слова клон
            $newobj = clone $obj; 
            // но конструктор не вызовиться, он вызывается только при создании. А иногда нужно что-то сделать при копировании. Аналог конструктора для копирования.
          
          ?>

          <p>
          <h3>Лабараторка 1.3(клонирование)</h3>
          <p>
          <?php
            class User3 {
              function __construct($name, $login, $pass){
                $this->name = $name;
                $this->login = $login;
                $this->password = $pass;
              }
              function __destruct(){
                echo "<br>Пользователь ".$this->name.' удален';
              }
              function __clone(){
                $this->name = 'Guest';
                $this->login = 'guest';
                $this->password = '0000';
              }
              public function showInfo(){
                echo "<p>Name: ".$this->name;
                echo "<br>Login: ".$this->login;
                echo "<br>Password: ".$this->password;
              }
            }
            $user3_1 = new User3('John Smith','john','12345');
            $user3_1->showInfo();

            $user3_2 = new User3('Mike Dow','mike','0000');
            $user3_2->showInfo();

            $user3_3 = new User3('Ivan Petrov','ivan','1111');
            $user3_3->showInfo();

            $user3_4 = clone $user3_1;
            $user3_4->showInfo();
          ?>
          <p>
          <h2>Наследование</h2>
          <p>
          <p>У нас есть класс животные, мы хотим создат, от которогоь класс кошки. Глупо опять все дублировать в кошках. 
          <p>Животные будут так назваемым супер классом, от которого происходит наследование и свойства и методы автоматом перейдут другому.
          <p>Нам останется добавить чего нет.
          <p>
          <p>Человек описал класс. А если мы туда залазеем и добавляем что нам нужно - это нарушение инкопсуляции.
          <p>Некоторые языки имеют множественное наследование. Клас который берется от нескольких классов. ПХП этоне потдерживает.
          <p>
          <p>
          <h3>Лабараторка 1.4(наследование)</h3>
          <p>
          <?php
            class User4 {
              function __construct($name, $login, $pass){
                $this->name = $name;
                $this->login = $login;
                $this->password = $pass;
              }
              function __destruct(){
                echo "<br>Пользователь ".$this->name.' удален';
              }
              function __clone(){
                $this->name = 'Guest';
                $this->login = 'guest';
                $this->password = '0000';
              }
              public function showInfo(){
                echo "<p>Name: ".$this->name;
                echo "<br>Login: ".$this->login;
                echo "<br>Password: ".$this->password;
              }
            }
            $user4_1 = new User4('John Smith','john','12345');
            $user4_1->showInfo();

            $user4_2 = new User4('Mike Dow','mike','0000');
            $user4_2->showInfo();

            $user4_3 = new User4('Ivan Petrov','ivan','1111');
            $user4_3->showInfo();

            $user4_4 = clone $user4_1;
            $user4_4->showInfo();

            class SuperUser extends User4{
              public $role;
            }
            $user4_5 = new SuperUser('Vasya Pupkin', 'vasya', 'qwe');
            $user4_5->role = 'admin';
            $user4_5->showInfo();
            echo "<br>Role: ".$user4_5->role;
          ?>
          <p>
          <h2>Перегрузка методов</h2>
          <p>Что если мы хотим, чтобы роль выводилась методом, и в дальнейших наследоваий была.
          <p>Что есля я опишу в классе наследнике метод с таким же именем как у суперкласса.(называется перегрузил метод)
          <p>На закидывать зановго весь конструктор ради одного метода как то бредово.
          <p>У нас есть возможность обратиться к родителю (peaent::MyMethod)
          <p>
          <h3>Лабараторка 1.5(Использование родительских методов)</h3>
          <p>
          <?php
            class User5 {
              function __construct($name, $login, $pass){
                $this->name = $name;
                $this->login = $login;
                $this->password = $pass;
              }
              function __destruct(){
                echo "<br>Пользователь ".$this->name.' удален';
              }
              function __clone(){
                $this->name = 'Guest';
                $this->login = 'guest';
                $this->password = '0000';
              }
              public function showInfo(){
                echo "<p>Name: ".$this->name;
                echo "<br>Login: ".$this->login;
                echo "<br>Password: ".$this->password;
              }
            }
            $user5_1 = new User5('John Smith','john','12345');
            $user5_1->showInfo();

            $user5_4 = clone $user5_1;
            $user5_4->showInfo();

            class SuperUser5 extends User5{
              public $role;
              function __construct($name, $login, $pass, $role){
                parent::__construct($name, $login, $pass);
                $this->role = $role;
              }
              public function showInfo(){
                parent::showInfo();
                echo "<br>Role: ".$this->role;
              }
            }
            $user5_5 = new SuperUser5('Vasya Pupkin', 'vasya', 'qwe', 'admin');
            $user5_5->showInfo();
          ?>
          <p>
          <h2>Модификаторы доступа</h2>
          <p>
          <p>У нас три области видимости: глобальная, область видимости класса, класс наследник
          <p>
          <p>public(общедоступный) - из любого места
          <p>protected(защищеный) - и в родительском и в наследуемом
          <p>privatr(закрытый) - только клас в котором объявлен
          <p>
          <p>Но к ним можно обратиться. Нужно описать метод, который и обратиться к ним function getY(){return $this->y;}
          <p>Мы обращаемся к методу который в классе, а он уже обращается из класса.
          <p>Это переменные для внутреннего пользования, их не надо дергать. Я их не перезапишу, но могу вызвать метод который возвращает то что нужно 
          <p>
          <p>Из класса наследника к прайву мы не можем обратиться.
          <p>
          <p>Как правило в ООП принято закрытые переменные начинать со знака подчеркивание $_param. Но у нас в пхп есть знак $
          <p>
          <p>
          <h2>Обработка исключений (try catch - throw new Exception)</h2>
          <p>
          <p>У нас иногда могут выпасть не критичные ошибки. Можно дальше продолжать код
          <p>
          <?php
            try {
              $a = 1;
              $b = 0;
              if ($b == 0)
                throw new Exception('Деление на 0 - '); // Генерируется исключение
                // Exception - это встроенный класс, строка передается в конструктор
                // от сюда мы пригним в кейтчь,
              $c = $a / $b; // этот код не когда не исполнится 
            } catch (Exception $e){ // trow бросает этот объект в переменную $e
              // теоритически мы можем сдесь вообще не чего не делать
              echo $e->getMessage(); // Выдает то, что мы бросили в конструктор
              echo $e->getLine(); // Выдает строчку где мы возбудили метод
              echo $e->getFile(); // Има этого файла
            }
          ?>
          <p>1) В других языках есть блок файнели, в который мы попадаем не зависимо от того дошли то кетча или не дошли
          <p>после трая туда и после кетча туда. В ПХП этого пока нет.
          <p>
          <p>2) что то с яваскрипт он сам падает в кейтчь. Типа кеть вызывается автоматом и пишит ошибку
          <p>
          <p>3) Нельзя вызвать в нутри класса в глобальной видимости, только в нутри метода
          <p>
          <p>Можно делать много троу нью эксепшен в трае, а отлавливать их в одном месте
          <p>Можно сделать наследуемый класс и добавить своих методов(теперь при ошибки будет исполняться вой код помимо сообщений )
          <p>
          <h2>Перебор</h2>
          <p>
          <p>На самом деле в форитчь можно передовать не только массив, но и объект
          <p>Будет бегать по свойствам объекта, как ассоциативный массив 
          <p>
          <h2>Константы класса (const, self::)</h2>
          <p>
          <?php
            class Human {
              const HANDS = 2;
              function printHands(){
                echo self::HANDS;
              }
            }
          ?>
          <p>Они не пренадлежать объектам. Константа общая на все объекты.
          <p>Если ее использовать в методе, то нельзя использовать this, ведь она не имеет отношение к объекту. Используем self.
          <p>self - это не посредственно обращение к самому классу
          <p>
          <p>Иногда нам надо обратиться к константе и вне
          <p>echo 'Колличество рук: ' . Human::HENDS; // имя класса, двойное двоеточие, име константы
          <p>
          <h2>Абстрактнык методы и классы (abstract)</h2>
          <p>
          <p>Класс сам по себе обстракция, но мы можем еще больше заобстрактить
          <p>Мы пишем класс и придумали что какой-то мтод будет, но я пока его не описываю
          <p>Я создал класс ДБ, и прописал метод конект, заделарировал методы: запрос, закрытие.
          <p>Вы каждый из разработчиков пишите эти методы сами, а ях просто задекларировал.
          <p>Я объявляю этот класс опстракным, а эти методы обстрактными
          <p>
          <?php
            abstract class Db {
              public $cnn;
              function connect(){
                // ..code
              }
              abstract function open();
              abstract function query();
              abstract function close();
            }
          ?>
          <p>
          <p>Что это нам дает?
          <p>1) Если класс объявлен как абстратный, то от него нельзясоздать экземпляр этого класса.
          <p>его можно только наследовать. От наброска нельзя сделать телевизор, это общий набросок.
          <p>Абстрактный метод, это метод без реализации. У метода нет не тела, нет фигурных скобок.
          <p>
          <p>Нужно создать свой класс
          <p>class MyDb extance Db{}
          <p>x = new MyDb;
          <p>
          <p>абстрактный класс не объязательно имеет абстрактные методы. Он будет просто не для того чтобы создовать ноды.
          <p>Но если в классе объявлен абстрактный метод, то вест класс должен быть объявлен как абстрактный.
          <p>
          <p>пхп выдаст ошибку. Обстрактные методы нужно описать. Их нужно перегрузить.
          <p>class MyDb extance Db{
          <p>   function open(){}
          <p>   function query(){}
          <p>   function close(){}
          <p>}
          <p>как минимум нужно сделать так 
          <p>
          <p>В больших проетах все как правило начинается с абстракций.
          <p>Мы решили расширить класс делаем абстракт, наш программист с утра запускает код а у него не объявлен абстрактный класс - ошибка. Он должен описать.
          <p>Эти методы обезательно там будут.
          <p>
          <p>
          <h2>Интерфейс (interfase, implements)</h2>
          <p>
          <p>Это абстрактный класс, который имеет только абстрактные методы
          <p>По скольку все методы абстрактные слово абстракт к ним не нужно
          <p>а слово абстракт перед классом заменяется interfase
          <p>
          <p>На языке ооп интерфейс это контракт, мы договариваемя между собой
          <p>
          <p>Интерфейс наследуется с помощью слова implements
          <p>В отличии от класса мы можем наследовать сколько угодно классов через запятую
          <p>
          <p>Слабое место: если мы предпологаем, что класс будет наследован одновременно два интерфейса, 
          <p>то у них не может быть одноименных методов. Мы же обязанны перегрузить.
          <p>
          <p>Один интерфейс, много реализаций
          <p>
          <p>
            <h3>Лабараторка 1.6(Абстракции и интерфейсы)</h3>
          <p>
          <?php
            abstract class AUser6{
              abstract function showInfo();
            }
            class User6 extends AUser6 { 
              function __construct($name, $login, $pass){
                $this->name = $name;
                $this->login = $login;
                $this->password = $pass;
              }
              function __destruct(){
                echo "<br>Пользователь ".$this->name.' удален';
              }
              function __clone(){
                $this->name = 'Guest';
                $this->login = 'guest';
                $this->password = '0000';
              }
              public function showInfo(){
                echo "<p>Name: ".$this->name;
                echo "<br>Login: ".$this->login;
                echo "<br>Password: ".$this->password;
              }
            }
            $user6_1 = new User6('John Smith','john','12345');
            $user6_1->showInfo();

            $user6_4 = clone $user6_1;
            $user6_4->showInfo();

            interface ISuperUser6 {
              function getInfo();
            }
            class SuperUser6 extends User6 implements ISuperUser6 {
              public $role;
              function __construct($name, $login, $pass, $role){
                parent::__construct($name, $login, $pass);
                $this->role = $role;
              }
              public function showInfo(){
                parent::showInfo();
                echo "<br>Role: ".$this->role;
              }
              function getInfo(){
                // главное чтобы он вернул массив. Но зачем я не понял. Может в задании к лаараторке надо
                $arr = array();
                foreach ($this as $key => $value) {
                  $arr[$key] = $value;
                }
                return $arr;
                // return (array)$this; // альтернативная реализация
              }

            }
            $user5_6 = new SuperUser6('Vasya Pupkin', 'vasya', 'qwe', 'admin');
            $user5_6->showInfo();
            print_r($user5_6->getInfo()); // я вывел массив, наверное все-таки задание такое было 
          ?>
          <p>
          <p>
          <h2>Финальные методы(final), финальные классы</h2>
          <p>
          <p>Финальный методы не могут быть перегружены
          <p>Скорее используется для того, когда автор еще не доделал метод
          <p>Чтобы люде не подсажиались, перегрузит у себя и так далее, а он потом изменит и у всех поломается
          <p>final function countSum(){}
          <p>
          <p>как и методы весь класс может быть финальным объявлен. Его нельзя наследовать.
          <p>Я его не доделал, чтобы люди не делали цепочек.
          <p>
          <p>final class breackfist
          <p>
          <p>
            <h2>Статические свойства и методы(static, self::)</h2>
          <p>
          <p>статические переменные в предыдщем курсе(это переменные которые по выходу не теряют свое значение и становлясь глобальными)
          <p>
          <p>статичное свойство метода объявляется свойством статик
          <p>public static $loversCount = 0;
          <p>статическое свойство оно одно на всех, как и константа
          <p>в связи с этим доступ к свойству из нутри класса через сет. Нужно дописать долар иначе будет расценен как константа класса
          <p>
          <p>function __constract() {
          <p>   ++self::$loversCount;
          <p>}
          <p>из глобальной видимости мы обращаемся как имяКласса::$переменная
          <p>++ подсчитывают сколько экземпляров класса создано(просто пример применения)
          <p>
          <p>статический метод
          <p>satatic function welcome(){} 
          <p>доступ внутри через селф, с наружи ИмяКласса::имяметода();
          <p>
          <p>Зачем статические методы делаются?
          <p>Пространство имен, чтобы не пересикались переменные. Но пространство имен появлисоль только в 5.3
          <p>По этому классы использовали как обертку над методом, двойное двоеточие предохраняло от одинаковых переменных
          <p>или
          <p>для того чтобы к ни обратиться не создовая лишнего экземпляра класса
          <p>
            <h2>Динамические статестические вызовы(ПХП 5.3)</h2>
          <p>
          <p>public static function foo() {
          <p>   echo __METHOD__;
          <p>}
          <p>$class = 'Helper';
          <p>$method = 'foo';
          <p>$class::$method();
          <p>
          <p>теперь мы можим иметь имя класса в переменной, и метод в переменной и ображаться к ним
          <p>

            <h3>Лабараторка 1.7(Статические свойства и методы)</h3>
          <p>будем считать юзеров и суперюзеров отдельно
          <?php
            abstract class AUser7{
              abstract function showInfo();
            }
            class User7 extends AUser7 { 
              public static $cntU = 0; // +
              function __construct($name, $login, $pass){
                $this->name = $name;
                $this->login = $login;
                $this->password = $pass;
                ++self::$cntU; // +
              }
              function __destruct(){
                echo "<br>Пользователь ".$this->name.' удален';
              }
              function __clone(){
                $this->name = 'Guest';
                $this->login = 'guest';
                $this->password = '0000';
                 // при клонировании конструктор не вызывается
                ++self::$cntU; // нужно счетчик поместить и сюда
              }
              public function showInfo(){
                echo "<p>Name: ".$this->name;
                echo "<br>Login: ".$this->login;
                echo "<br>Password: ".$this->password;
              }
            }
            $user7_1 = new User7('John Smith','john','12345');
            $user7_1->showInfo();

            $user7_4 = clone $user7_1;
            $user7_4->showInfo();

            interface ISuperUser7 {
              function getInfo();
            }
            class SuperUser7 extends User7 implements ISuperUser7 {
              public $role;
              public static $cntSU = 0;
              function __construct($name, $login, $pass, $role){
                parent::__construct($name, $login, $pass);
                $this->role = $role;
                ++self::$cntSU; // вызывается родительский консруктор и увеличивает и его значение
                //--self::$cntSU; // мы отнимаем чтобы он не считал его
                // пожно парент использловать так более явно
                --parent::$cntSU;
              }
              public function showInfo(){
                parent::showInfo();
                echo "<br>Role: ".$this->role;
              }
              function getInfo(){
                return (array)$this; // альтернативная реализация
              }
            }
            // $user7_6 = new SuperUser7('Vasya Pupkin', 'vasya', 'qwe', 'admin'); перестало работать, не стал разбираться почему
            // $user7_6->showInfo();
            echo "<hr>";
            echo "Всего простых юзеров: ".User7::$cntU."<br>";
            echo "Всего простых админов: ".SuperUser7::$cntSU.'<hr>';
          ?>
          <p>
            <h2>Проверить есть ли в предках класс(instanceOf)</h2>
          <p>class Human{}
          <p>$myBoss = mew Human();
          <p>if($myBoss instanceOf Human) {
          <p>   echo 'Мой босс - человек';
          <p>}
          <p>Отслеживается вся цепочка. Интерфейс тоже класс.
          <p>
          <p>is_a($obj, 'Class'); // функция, принимает обект и имя класса
          <p>возвращает тру если является наследником этого класса и фолс если нет
          <p>тоже самое что и оператор инстанс
          <p>так было в ПХП4, но в джаве инстанс оф, и они обявили ис_а деплекейт. Но потом вернули
          <p>
          <p>1:03 закончил 
          <p>
          <h2>Автозагрузка классов (__autoload)</h2>
          <p>
          <p>$x = new A; // выдаст ошибку, однако
          <p>сначало интерпритатор пойдет и посмотрит функцию автолоад и передест в нее имя класса
          <p>
          <p>function __autoload($name) {
          <p>   echo $name;
          <p>}
          <p>ошибка выскачет после
          <p>
          <p>в ооп принято каждый класс описывать в отдельном файле, не важно маленький или большой 
          <p>функция автолоад позволяет не подключать их по 20 раз в каждом файле
          <p>не кто нам не мешает сделать класс отдельным файлом и сохранить под таким же именем как и класс(в джава это вообще обязательное требование)
          <p>
          <p>function __autoload($name) {
          <p>   include $name.'.class.php';
          <p>}
          <p>он класса не находит вызывает функцию, передает туда имя, мы делаем инклюд, класс нашелся, все в порядке
          <p>
            <h2>Доступ к невидимым свойствам(__set, __get)</h2>
          <p>
          <p>class Person{}
          <p>$x = new Person;
          <p>$x->name = 'John';
          <p>echo $x->name; // выведет джона
          <p>
          <p>Это не баг, это фича. Динамически создал нейм.
          <p>Эта вещь не очень хорошая
          <p>
          <p>Если пхп не видит нужного свойства(по разным причинам: отсутствует, приватное)
          <p>прежде чем выдать ошибку, он смотрит не описали ли мы в нутри класса метод __set
          <p>если описали, то он его вызывает передовая туда два параметра
          <p>
          <p>class Person{
          <p>   function __set($name, $value){
          <p>     
          <p>   }
          <p>}
          <p>
          <p>первый параметр: имя поля которое он не нашел(в нашем случае нейм), и значение которое мы присваиваем
          <p>
          <p>class Person{
          <p>private $data = array(); 
          <p>   function __set($name, $value){
          <p>     $this->data[$name] = $value;
          <p>   }
          <p>}
          <p>echo $x->name; // прежде чем выполнить запрос он смотрит не описан ли магический метод __get
          <p>
          <p>class Person{
          <p>private $data = array(); 
          <p>   function __set($name, $value){
          <p>     $this->data[$name] = $value;
          <p>   }
          <p>   function __get($name){
          <p>     return $this->data[$name];
          <p>   }
          <p>}
          <p>если описан, то он его дергает передавая туда в качестве параметра имя которое вызываем
          <p>
            <h2>Доступ к невидимым методам(__call, callStatic)</h2>
          <p>
          <p>Если следует обращение к методы которого нет, то прежде чем выдать ошибку
          <p>Ищится, а не описал ли я магический метод __call($name, $args){}
          <p>куда передается имя метода, и массив аргументов
          <p>
          <p>в версии пхп5.3 появилось тоже самое для статических методов
          <p>class MethodTest {
          <p>   public static function __callStatic($name, $a){
          <p>     echo "вызов метода '$name' ".implode(', ', $a);
          <p>   }
          <p>}
          <p>если вы дерните статический метод(которого нет или не видит пхп), то объявляем колстатик
          <p>имя $нейм регистрозависимое
          <p>
            <h2>Приведение объекта к строке(__toString)</h2>
          <p>
          <p>Когда мы пытаемся привести объект к строки(тип), прежде чем выдать ошибку
          <p>смотрится а нет ли магического метода __toString(){}, то он вызывается
          <p>
            <h2>Объект как функция(пхп5.4)(__invoke)</h2>
          <p>
          <p>Мы можем обратиться к объекту как к функции
          <p>echo $obj(5);
          <p>когда идет обращение к объекту как к функции, прежде чем выдать ошибку 
          <p>смотрит есть ли инфок, и передается значение которое мы передали в вызове
          <p>public function __invoke($var){}
          <p>
            <h2>Контроль типа(type-hint, callable)</h2>
          <p>Проверить предоваемый переменная 
          <p>
          <p>function foo(ClassA $obj){ /* Ожидается только экземпляр класса ClassA */ }
          <p>
          <p>function foo(callable $x) {
          <p>   return $x;
          <p>}
          <p>коллейбол говорит, что суда можно передать нечто вызываемое, то что можно вызвать(пример функцию)
          <p>можно передать имя функции, но так же мы можем передать статический метод класса(массив: сначало имя класса, потом имя метода)
          <p>foo(['ClassName'], 'staticMethodName');
          <p>
          <p>можно передать простой метод, но нужно передать объект и имя метода объекта которого надо вызвать
          <p>foo($obj, 'methodName');
          <p>
          <p>foo($invokableObject);
          <p> 
            <h2>Сериализация(__sleep, __wakeup)</h2>
          <p>(переброситьобъект через строку)
          <p>Тепичный пример мы хотим сохранить объект в сессии
          <p>Если объект просто так серелиазивать, то он будет пустым. 
          <p>Серелиализуется только значение свойств. Мы должны сообщить, руками, принудительно значение каких свойств мы хотим сохранить.
          <p>Для этого у нас есть магический метод слип.
          <p>Слип должен возвращать массив имен свойств в виде строк.
          <p>После при  ансиреалайзе этот объект распакуется.
          <p>Но у нас в полне возможно есть конструктор. Мы создали объект, переходим на другую страницу, сериализуем, но
          <p>объект та уже есть, конструктор не вызывается. А нам нужно чтобы к примеру соединение с базой дернулось.
          <p>Для этой цели мы описываем магический метод вэйк ап. После того как он дернится после этого исплонится.
          <p>
            <h2>Наследование (traits, use)(PHP 5.4)</h2>
          <p>
          <p>Столкнулись с тем, что пхп не использует множественное наследование.
          <p>Трейды это самый обычный класс, но  от них нельзя инстанцииировать объект.
          <p>Они как инклюдеты(не имеют самостоятельного запуска)
          <p>
          <p>Изменение модификаторов
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p>
          <p><br><br><br><br><br><br><br><br><br><br>





















          <?php the_content(); ?>
        </article>
      <?php endwhile; ?>

    </main>
</div>
<?php get_footer(); ?>


